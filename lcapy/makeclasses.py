from lcapy.domains import domains
from lcapy.voltagemixin import VoltageMixin
from lcapy.currentmixin import CurrentMixin
from lcapy.admittancemixin import AdmittanceMixin
from lcapy.impedancemixin import ImpedanceMixin
from lcapy.transfermixin import TransferMixin
from lcapy.voltagesquaredmixin import VoltageSquaredMixin
from lcapy.currentsquaredmixin import CurrentSquaredMixin
from lcapy.admittancesquaredmixin import AdmittanceSquaredMixin
from lcapy.impedancesquaredmixin import ImpedanceSquaredMixin
from lcapy.powermixin import PowerMixin


quantityclasses = {'voltage': VoltageMixin,
                   'current': CurrentMixin,
                   'admittance': AdmittanceMixin,
                   'impedance': ImpedanceMixin,
                   'transfer': TransferMixin,
                   'voltagesquared': VoltageSquaredMixin,
                   'currentsquared': CurrentSquaredMixin,
                   'admittancesquared': AdmittanceSquaredMixin,
                   'impedancesquared': ImpedanceSquaredMixin,
                   'power': PowerMixin}


units_mapping = {
    '': 'S.One',
    'V': 'uu.volt', 'A': 'uu.ampere',
    'V/Hz': 'uu.volt / uu.Hz',
    'A/Hz': 'uu.ampere / uu.Hz',
    'V/sqrt(Hz)': 'uu.volt / sqrt(uu.Hz)',
    'A/sqrt(Hz)': 'uu.ampere / sqrt(uu.Hz)',
    'ohm': 'uu.ohm',
    'S': 'uu.siemens',
    'ohm/s': 'uu.ohm / uu.s',
    'S/s': 'uu.siemens / uu.s',
    'ohm^2/s^2': '(uu.ohm / uu.s)**2',
    'S^2/s^2': '(uu.siemens / uu.s)**2',
    'V^2': 'uu.volt**2',
    'A^2': 'uu.ampere**2',
    'V^2/Hz^2': '(uu.volt / uu.Hz)**2',
    'A^2/Hz^2': '(uu.ampere / uu.Hz)**2',
    'ohm^2': 'uu.ohm**2', 'S^2': 'uu.siemens**2',
    'W': 'uu.watt', '/s': '1 / uu.s'}


class ExprClassesMake:

    def __init__(self):

        self.classes = []
        self.all = []
        self.cdict = {}

    def make(self, domains, quantities):

        for domain in domains:

            if domain.is_superposition_domain:
                continue

            self.cdict[domain.domain] = {}

            self.cdict[domain.domain]['undefined'] = domain.__name__ + 'Expression'

            for quantity in quantities:

                class_maker = ExprClassMake(domain, quantity)

                name, s = class_maker.make()
                self.all.append(name)
                self.classes.append(s)

                self.cdict[domain.domain][quantity] = name

                if (domain.is_discrete_time_domain or
                        domain.is_discrete_fourier_domain or domain.is_Z_domain):
                    name, s = class_maker.make('Sequence')
                    self.all.append(name)
                    self.classes.append(s)

    def write(self):

        s = '''
# This file is automatically generated by makeclasses.py

from .cexpr import ConstantDomainExpression
from .fexpr import FourierDomainExpression
from .jfexpr import FrequencyResponseDomainExpression
from .jomegaexpr import AngularFrequencyResponseDomainExpression
from .kexpr import DiscreteFourierDomainExpression
from .kseq import DiscreteFourierDomainSequence
from .nexpr import DiscreteTimeDomainExpression
from .nseq import DiscreteTimeDomainSequence
from .noisefexpr import FourierNoiseDomainExpression
from .noiseomegaexpr import AngularFourierNoiseDomainExpression
from .normfexpr import NormFourierDomainExpression
from .normomegaexpr import NormAngularFourierDomainExpression
from .omegaexpr import AngularFourierDomainExpression
from .phasor import PhasorDomainExpression, PhasorRatioDomainExpression
from .sexpr import LaplaceDomainExpression
from .texpr import TimeDomainExpression
from .uexpr import UndefinedDomainExpression
from .zexpr import ZDomainExpression
from .zseq import ZDomainSequence
from .units import units, u as uu
from .voltagemixin import VoltageMixin
from .currentmixin import CurrentMixin
from .admittancemixin import AdmittanceMixin
from .impedancemixin import ImpedanceMixin
from .transfermixin import TransferMixin
from .voltagesquaredmixin import VoltageSquaredMixin
from .currentsquaredmixin import CurrentSquaredMixin
from .admittancesquaredmixin import AdmittanceSquaredMixin
from .impedancesquaredmixin import ImpedanceSquaredMixin
from .powermixin import PowerMixin
from sympy import sqrt, S


'''
        s += '__all__ = (' + ', '.join(["'" + name +
                                        "'" for name in self.all]) + ')' + '\n'

        s += '\n'.join(self.classes)

        s += '\nexprclasses = {'

        for d, dv in self.cdict.items():
            s += "'" + d + "': {"
            for q, qv in dv.items():
                s += "'" + q + "': " + qv + ',\n'
            s += '}\n,'
        s += '}\n'

        with open('exprclasses.py', 'wt') as outfile:
            print(s, file=outfile)


class ExprClassMake:

    def __init__(self, domainclass, quantity):

        self.domainclass = domainclass
        self.quantity = quantity

    def make(self, kind='Expression'):

        quantity = self.quantity
        domainclass = self.domainclass

        quantityclass = quantityclasses[quantity]
        quantityunits = quantityclass.quantity_units

        unitsstring = quantityunits
        if quantity in ('voltage', 'current'):
            if (domainclass.is_laplace_domain or
                domainclass.is_fourier_domain or
                    domainclass.is_angular_fourier_domain):
                unitsstring = '%s/Hz' % quantityunits
        elif quantity in ('voltagesquared', 'currentsquared'):
            if (domainclass.is_laplace_domain or
                domainclass.is_fourier_domain or
                    domainclass.is_angular_fourier_domain):
                unitsstring = '%s/Hz^2' % quantityunits
        elif quantity in ('impedance', 'admittance', 'transfer'):
            if domainclass.is_time_domain:
                unitsstring = '%s/s' % quantityunits
        elif quantity in ('admittancesquared', 'impedancesquared'):
            if domainclass.is_time_domain:
                unitsstring = '%s/s^2' % quantityunits

        classname = domainclass.__name__ + quantityclass.quantity.capitalize()
        classname = classname.replace('Transfer', 'TransferFunction')

        baseclassname = domainclass.__name__ + kind

        if kind == 'Sequence':
            classname += kind

        # TODO: perhaps rename transfer function in time domain to
        # impulse response?
        docstring = '%s-domain %s (units %s).' % (domainclass.domain_label,
                                                  quantity, unitsstring)

        s = '''


class % s( % s, % s):
    """%s"""

    _default_units = %s

''' % (classname, quantityclass.__name__, baseclassname,
            docstring,  units_mapping[unitsstring])

        return classname, s


quantities = quantityclasses.keys()

classes_maker = ExprClassesMake()

classes_maker.make(domains, quantities)

classes_maker.write()
