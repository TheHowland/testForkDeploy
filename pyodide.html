<!DOCTYPE html>
<html>
  <head>
    <script src="http://localhost:8000/pyodide.js"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
      #progress-container {
        width: 100%;
        max-width: 200px;
        background-color: #f3f3f3;
      }
      #progress-bar {
        width: 0;
        max-width: 200px;
        height: 20px;
        background-color: #4caf50;
        text-align: center;
        line-height: 20px;
        color: white;
      }
    </style>
  </head>

  <body>
    <div id="simplification"></div>
    <script>
      class SolutionObject{
        constructor(name1, name2, newName, value1, value2, result, relation, latexEquation) {
          this._name1 = name1;
          this._name2 = name2;
          this._newName = newName;
          this._value1 = value1;
          this._value2 = value2;
          this._result = result;
          this._relation = relation;
          this._latexEquation = latexEquation;

          this._inlineReturnFunc = (string) => `\\(${string}\\)`;
          this._blockReturnFunc = (string) => `$$${string}$$`;

          this._returnFunction = this._inlineReturnFunc;
        }

        set returnFunction(func) {
          this._returnFunction = func;
        }

        inline() {
          this._returnFunction = this._inlineReturnFunc;
          return this;
        }

        block() {
          this._returnFunction = this._blockReturnFunc;
          return this;
        }

        noFormat() {
          this._returnFunction = (string) => string;
          return this;
        }

        _format(string) {
          return this._returnFunction(string);
        }

        isNull(){
          return (!this._name1) && (!this._name2) && (!this._newName) &&
                  (!this._value1) && (!this._value2) && (!this._result) &&
                  (!this._relation) && (!this._latexEquation);
        }

        get name1() {
          return this._format(this._name1);
        }

        get name2() {
          return this._format(this._name2);
        }

        get newName() {
          return this._format(this._newName);
        }

        get value1() {
          return this._format(this._value1);
        }

        get value2() {
          return this._format(this._value2);
        }

        get result() {
          return this._format(this._result);
        }

        get relation() {
          return this._format(this._relation);
        }

        get latexEquation() {
          return this._format(this._latexEquation);
        }

      }

      async function fetchDirectoryListing(url, extension = "") {
        try {
          // Fetch the directory listing HTML
          const response = await fetch(url);
          if (!response.ok) {
            throw new Error('Network response was not ok');
          }
          const htmlText = await response.text();

          // Parse the HTML
          const parser = new DOMParser();
          const doc = parser.parseFromString(htmlText, 'text/html');

          // Extract file names from the parsed HTML
          const fileLinks = doc.querySelectorAll('a'); // Assuming files are listed as <a> tags
          const fileNames = [];
          fileLinks.forEach(link => {
            const fileName = link.getAttribute('href');
            if (fileName && !fileName.endsWith('/')) { // Filter out directories if needed
              if(extension === "" || (extension !== "" && fileName.endsWith(extension))) {
                fileNames.push(fileName);
              }
            }
          });

          return fileNames;
        }
        catch (error) {
          console.error('Error fetching directory listing:', error);
          return [];
        }
      }

      function display_steps(pyodide, jsonFilePath, svgFilePath, contentDivName = 'simplification'){

        const contentDiv = document.getElementById(contentDivName);

        try {
          // Fetch JSON data
          let jsonDataString = pyodide.FS.readFile(jsonFilePath, { encoding: "utf8" });

          //console.log("Solution from Json:" + jsonDataString)
          const jsonData = JSON.parse(jsonDataString);
          let data = new SolutionObject(jsonData.name1, jsonData.name2, jsonData.newName, jsonData.value1, jsonData.value2,
                  jsonData.result, jsonData.relation, jsonData.latexEquation);

          // Fetch SVG data
          const svgData = pyodide.FS.readFile(svgFilePath, { encoding: "utf8" });

          if (!data.isNull()) {
            let relationText = ""
            if (data.noFormat().relation === "parallel") {
              relationText = "Die Elemente sind parallel zueinander";
            }
            else if (data.noFormat().relation === "series") {
              relationText = "Die Elemente sind in Reihe zueinander";
            }
            else if (data.noFormat().relation === null) {
              relationText = "Keine Beziehung zwischen den Elementen";
            }
            else {
              throw Error("Unknown relation type");
            }

            // Create a paragraph element to hold the JSON data
            const paragraph = document.createElement('p');
            paragraph.innerHTML = `Die Elemente ${data.inline().name1} und ${data.inline().name2}<br>
            wurden zu ${data.inline().newName} zusammengefasst<br>
            ${data.inline().name1}&nbsp= ${data.inline().value1}<br>
            ${data.inline().name2}&nbsp= ${data.inline().value2}<br>
            ${data.inline().newName}&nbsp= ${data.inline().result}<br>
            ${relationText}<br>
            Rechnung:<br>
            ${data.inline().latexEquation}`;

            contentDiv.appendChild(paragraph);
          }

          // Create a div element to hold the SVG data
          const svgDiv = document.createElement('div');
          //console.log("svg-Data:" + svgData)
          svgDiv.innerHTML = svgData;

          // Append the paragraph and SVG div to the content div
          contentDiv.appendChild(svgDiv);

          svgDiv.querySelectorAll('path').forEach(pathElement => {
            pathElement.style.pointerEvents = 'bounding-box';
            pathElement.style.cursor = 'pointer';

            pathElement.addEventListener('click', () => {
              const elementId = pathElement.getAttribute('id');
              if (elementId) {
                alert(`Clicked on path element with id: ${elementId}`);
              } else {
                alert('Clicked on a path element without an id');
              }
            });
          });
        } catch (error) {
          console.error('Error fetching data:', error);
          contentDiv.textContent = 'Error loading content';
        }
      }

      function createProgressBar(infoText) {
        const container = document.createElement('div');
        container.id = 'progress-container';

        const bar = document.createElement('div');
        bar.id = 'progress-bar';
        bar.textContent = '0%';

        container.appendChild(bar);
        document.body.appendChild(container);

        // Show the progress bar
        container.style.display = 'block';
      }

      function updateProgressBar(percentage) {
        const progressBar = document.getElementById('progress-bar');
        progressBar.style.width = percentage + '%';
        progressBar.textContent = percentage + '%';
      }

      function removeProgressBar() {
        const container = document.getElementById('progress-container');
        if (container) {
          container.remove();
        }
      }

      async function load_packages(pyodide, optAddNames){
        let timeLoadPackages = "Load packages"
        console.time(timeLoadPackages)
        createProgressBar("Loading Pyodide packages, please wait ...");
        updateProgressBar(0)
        let packageAddress = "http://localhost:8000/Packages/";
        let packages = await fetchDirectoryListing(packageAddress, ".whl")

        if(Array.isArray(optAddNames)){
          for(let i = 0; i < optAddNames.length; i++){
            packages.push(optAddNames[0])
          }
        }

        let progress = 0;
        const updateProgress = () => {
          progress += 1;
          updateProgressBar(Math.floor((progress / packages.length) * 100));
        };

        let packagePromises = packages.map(async function(packageName) {
          let pkgArrBuff = await (await fetch("http://localhost:8000/Packages/" + packageName)).arrayBuffer();
          let packageExtension = packageName.slice(packageName.lastIndexOf("."), packageName.length)
          await pyodide.unpackArchive(pkgArrBuff, packageExtension)
          updateProgress();
        })

        await Promise.all(packagePromises)
        console.log("Installed:" + packages)
        removeProgressBar()
        console.timeEnd(timeLoadPackages)
      }

      async function main() {
        const infoText = document.createElement('div')
        infoText.textContent = ""
        document.body.appendChild(infoText)
        infoText.setAttribute('style', 'white-space: pre;')

        infoText.textContent = "Loading Pyodide environment... "
        let pyodide = await loadPyodide();
        infoText.textContent += "done\r\n"

        infoText.textContent += "Loading necessary python packages, this may take a while... "
        await load_packages(pyodide, ["sqlite3-1.0.0.zip"])
        infoText.textContent += "done\r\n"


        let loadCircuits = "Load Circuits"
        infoText.textContent += "Loading circuits from server... "
        console.time(loadCircuits)

        // fetch netlist files from server
        let cirArrBuff = await (await fetch("http://localhost:8000/Circuits.zip")).arrayBuffer();
        await pyodide.unpackArchive(cirArrBuff, ".zip")

        // fetch simplification script from server
        pyodide.FS.writeFile("/home/pyodide/solve.py", await (await fetch("http://localhost:8000/solve.py")).text())
        infoText.textContent += "done\r\n"
        console.timeEnd(loadCircuits)

        let timeSolving = "Calculate solution"
        console.time(timeSolving)
        infoText.textContent += "calculating solution ..."

        let solve = pyodide.pyimport("solve");
        solve.solve_circuit("Circuit_resistors.txt")

        let files = await pyodide.FS.readdir("Solutions")

        //remove '.' and '..' from file list
        while (files[0] === "." || files[0] === ".."){
          files.splice(0, 1);
        }

        let jsonFiles = [];
        let svgFiles = [];
        files.forEach((file) => {
          if(file.search(".+\.json") >= 0){
            jsonFiles.push(file);
          }
          if(file.search(".+\.svg") >= 0){
            svgFiles.push(file);
          }
        })

        for(let i = 0; i < jsonFiles.length; i++){
          if(jsonFiles[i].replace(".json","") !== svgFiles[i].replace(".svg","")){
            pyodide.FS.rmdir("Solutions")
            throw new Error("Files did not match, Solutions cleared please try again")
          }
          display_steps(pyodide, "Solutions/"+jsonFiles[i], "Solutions/"+svgFiles[i])
        }
        infoText.textContent += "done\r\n"
        document.body.removeChild(infoText)
        console.timeEnd(timeSolving)
        MathJax.typeset()
      }
      main();
    </script>
  </body>
</html>