Schematics
==========

1. Automatically add wires with node splitting to avoid explicit wires

2. Add motor symbol

3. Add ferrite bead symbol (not supported by circuitikz)

4. Add crystal symbol (not supported by circuitikz)

5. Add drawing methods to TwoPorts

6. Handle multiple SVG images displayed in notebook due to problems with
shared namespace.

7. Automatically separate parallel components when drawing (except
open circuits).  The tricky part is adding enough space for the
labels.

8. Warn if have disjoint components.

9. Add user configuration file.


Circuit analysis
================

1. Add Vsin and Isin components for better Spice compatibility

2. Generalise two-port representation to avoid transformations from a
singular matrix.

3. Consider the behaviour of the impedance, admittance, and
transfer_function methods.  Currently, these return s-domain
expressions but if the circuit has only AC sources, should these
return omega-domain expressions?


Infrastructure
==============

1. Improve handling symbols of same name with different assumptions.
The problem arises when SymPy creates a symbol since it uses different
assumptions to Lcapy.  Ideally have a hook in sym.sympify.

2. Remove { when printing Piecewise with single condition?  Line 911
sympy/printing/pretty/pretty.py

3. Support more Fourier/Laplace transformations, say using a table
driven approach.

4. Speed up residue calculation (perhaps can try without taking limit...)

5. Speed up comparisons using is instead of ==

6. Warn user when calculations may take a while, say when inverting a
large matrix.

7. Add || operator to SymPy but this will require Python mods!

8. Rework notation for H, Y, and Z methods.

   The V and I methods currently return a Vsuper and Isuper class
   respectively.  This allows notation such as a.V1.V(t) and a.V1.V(s)
   to return the time-domain and s-domain expressions.  However, this
   notation does not work for H, Y, and Z methods.

   Currently to get the impulse response of a transfer function
   requires H.time() or H.impulse_response().  Using a wrapper class
   for H, Y, and Z methods would allow a notation H(t).

9. Generic wrapper classes.

   There can be confusion with the __call__ methods.  The Super class
   using the argument to determine the transformation, e.g., V(s), but
   the other classes use this for substitution, e.g., V(2).  Consider

   a1 = Vstep(5) + R(1)
   v = a1.V(t)
   v2 = v(f)

   Here v2 is not the frequency response of the open-circuit voltage
   as may be expected but the impulse response with f substituted for
   t.   Perhaps, a warning should be issued for incompatible domains?

   Another approach would use generic expression class for H, I, V, Y,
   and Z.

   This would have a default domain that is set when an instance of
   the class is created.  The __call__ method would return a new
   instance depending on the argument, for example:

   V(t)
   V(f)
   V(s)
   V(omega)   V(f) with f = omega / (2 * pi)
   V(jomega)  V(s) with s = j * omega

   If a constant is passed, the expression would be evaluated with the
   default variable set to the constant, for example,
   V(t)(3)

   The results of operations using this class would be rewrapped with
   the appropriate generic class.

   A difficulty with the approach is indicating to the user the
   current domain, especially for constants.  For example, does 3
   represent v(t) = 3 or V(s) = 3?

   Another consideration is whether symbols such as t or s should be
   wrapped with this class.



Testing
=======

1. Write more unit tests


Documentation
=============

1. Add example notebooks

2. Add user manual

3. Document underlying philosophy

4. Fix shape node labels


Additional features
===================

1. Handle mechanical and acoustical components.  Perhaps use lower case for
mechanical/acoustical.  For example,

   Force      f  (N)
   Mass       m  (kg)
   Spring     k  (N/m)
   Damper     r  (kg/s)
   Velocity   u  (m/s)

   Could support both electro-mechnical analogues?  cct.electrical_analogue(1)?
   m -> L, C
   k -> C, L
   f -> I, V
   u -> V, I

2. Expand two-ports, xtals, opamps, etc.  cct = cct.expand() Perhaps
have arg to expand to select components and/or types of component to
expand?

When expanding, still need to know original nodes for determining
voltage, say across a capacitor when it expanded into a series
comb. of an impedance and voltage source.  Perhaps retain the
component in the netlist but prefix it with some symbol such as @.
So C1 2 1 5 2 expands to
C#1 2 dummy 5
V#1 dummy 1 2
@C1 2 1 5 2

Here the @symbol says not to draw or analyse cpt.  But the name C1
will be added to the directories for the current and voltage.

3. Add passive network synthesis to generate R, L, C network given an
impedance...


SymPy
=====

1. Advocate for SymPy to consider lower limit of Laplace transform integral
to sneak past 0 so that DiracDelta(t) -> 1 instead of 0.5

2. Contribute Fourier/Laplace code

